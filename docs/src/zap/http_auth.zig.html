<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>http_auth.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> zap = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;zap.zig&quot;</span>);</span>
<span class="line" id="L3"></span>
<span class="line" id="L4"><span class="tok-comment">/// Authentication Scheme enum: Basic or Bearer.</span></span>
<span class="line" id="L5"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AuthScheme = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L6">    Basic,</span>
<span class="line" id="L7">    Bearer,</span>
<span class="line" id="L8"></span>
<span class="line" id="L9">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">str</span>(self: AuthScheme) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L10">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {</span>
<span class="line" id="L11">            .Basic =&gt; <span class="tok-str">&quot;Basic &quot;</span>,</span>
<span class="line" id="L12">            .Bearer =&gt; <span class="tok-str">&quot;Bearer &quot;</span>,</span>
<span class="line" id="L13">        };</span>
<span class="line" id="L14">    }</span>
<span class="line" id="L15"></span>
<span class="line" id="L16">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">headerFieldStrFio</span>(self: AuthScheme) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L17">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {</span>
<span class="line" id="L18">            .Basic =&gt; <span class="tok-str">&quot;authentication&quot;</span>,</span>
<span class="line" id="L19">            .Bearer =&gt; <span class="tok-str">&quot;authorization&quot;</span>,</span>
<span class="line" id="L20">        };</span>
<span class="line" id="L21">    }</span>
<span class="line" id="L22"></span>
<span class="line" id="L23">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">headerFieldStrHeader</span>(self: AuthScheme) [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L24">        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {</span>
<span class="line" id="L25">            .Basic =&gt; <span class="tok-str">&quot;Authentication&quot;</span>,</span>
<span class="line" id="L26">            .Bearer =&gt; <span class="tok-str">&quot;Authorization&quot;</span>,</span>
<span class="line" id="L27">        };</span>
<span class="line" id="L28">    }</span>
<span class="line" id="L29">};</span>
<span class="line" id="L30"></span>
<span class="line" id="L31"><span class="tok-comment">/// Used internally: check for presence of the requested auth header.</span></span>
<span class="line" id="L32"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">checkAuthHeader</span>(scheme: AuthScheme, auth_header: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L33">    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (scheme) {</span>
<span class="line" id="L34">        .Basic =&gt; |b| std.mem.startsWith(<span class="tok-type">u8</span>, auth_header, b.str()) <span class="tok-kw">and</span> auth_header.len &gt; b.str().len,</span>
<span class="line" id="L35">        .Bearer =&gt; |b| std.mem.startsWith(<span class="tok-type">u8</span>, auth_header, b.str()) <span class="tok-kw">and</span> auth_header.len &gt; b.str().len,</span>
<span class="line" id="L36">    };</span>
<span class="line" id="L37">}</span>
<span class="line" id="L38"></span>
<span class="line" id="L39"><span class="tok-comment">/// Used internally: return the requested auth header.</span></span>
<span class="line" id="L40"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">extractAuthHeader</span>(scheme: AuthScheme, r: *<span class="tok-kw">const</span> zap.Request) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L41">    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (scheme) {</span>
<span class="line" id="L42">        .Basic =&gt; |b| r.getHeader(b.headerFieldStrFio()),</span>
<span class="line" id="L43">        .Bearer =&gt; |b| r.getHeader(b.headerFieldStrFio()),</span>
<span class="line" id="L44">    };</span>
<span class="line" id="L45">}</span>
<span class="line" id="L46"></span>
<span class="line" id="L47"><span class="tok-comment">/// Decoding Strategy for Basic Authentication</span></span>
<span class="line" id="L48"><span class="tok-kw">const</span> BasicAuthStrategy = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L49">    <span class="tok-comment">/// decode into user and pass, then check pass</span></span>
<span class="line" id="L50">    UserPass,</span>
<span class="line" id="L51">    <span class="tok-comment">/// just look up the encoded user:pass token</span></span>
<span class="line" id="L52">    Token68,</span>
<span class="line" id="L53">};</span>
<span class="line" id="L54"></span>
<span class="line" id="L55"><span class="tok-comment">/// Authentication result</span></span>
<span class="line" id="L56"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> AuthResult = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L57">    <span class="tok-comment">/// authentication / authorization was successful</span></span>
<span class="line" id="L58">    AuthOK,</span>
<span class="line" id="L59">    <span class="tok-comment">/// authentication / authorization failed</span></span>
<span class="line" id="L60">    AuthFailed,</span>
<span class="line" id="L61">    <span class="tok-comment">/// The authenticator handled the request that didn't pass authentication /</span></span>
<span class="line" id="L62">    <span class="tok-comment">/// authorization.</span></span>
<span class="line" id="L63">    <span class="tok-comment">/// This is used to implement authenticators that redirect to a login</span></span>
<span class="line" id="L64">    <span class="tok-comment">/// page. An Authenticating endpoint will not do the default, which is trying</span></span>
<span class="line" id="L65">    <span class="tok-comment">/// to call the `unauthorized` callback if one exists orelse ignore the request.</span></span>
<span class="line" id="L66">    Handled,</span>
<span class="line" id="L67">};</span>
<span class="line" id="L68"></span>
<span class="line" id="L69"><span class="tok-comment">/// HTTP Basic Authentication RFC 7617.</span></span>
<span class="line" id="L70"><span class="tok-comment">/// &quot;Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==&quot;</span></span>
<span class="line" id="L71"><span class="tok-comment">/// user-pass strings: &quot;$username:$password&quot; -&gt; base64</span></span>
<span class="line" id="L72"><span class="tok-comment">///</span></span>
<span class="line" id="L73"><span class="tok-comment">/// Notes:</span></span>
<span class="line" id="L74"><span class="tok-comment">///   - we only look at the Authentication header</span></span>
<span class="line" id="L75"><span class="tok-comment">///   - we ignore the required realm parameter</span></span>
<span class="line" id="L76"><span class="tok-comment">///   - we ignore the optional charset parameter</span></span>
<span class="line" id="L77"><span class="tok-comment">///</span></span>
<span class="line" id="L78"><span class="tok-comment">/// Errors:</span></span>
<span class="line" id="L79"><span class="tok-comment">/// WWW-Authenticate: Basic realm=&quot;this&quot;</span></span>
<span class="line" id="L80"><span class="tok-comment">///</span></span>
<span class="line" id="L81"><span class="tok-comment">/// Lookup : any kind of map that implements get([]const u8) -&gt; []const u8</span></span>
<span class="line" id="L82"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Basic</span>(<span class="tok-kw">comptime</span> Lookup: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> kind: BasicAuthStrategy) <span class="tok-type">type</span> {</span>
<span class="line" id="L83">    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L84">        allocator: std.mem.Allocator,</span>
<span class="line" id="L85">        realm: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L86">        lookup: *Lookup,</span>
<span class="line" id="L87"></span>
<span class="line" id="L88">        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L89"></span>
<span class="line" id="L90">        <span class="tok-comment">/// Creates a BasicAuth. `lookup` must implement `.get([]const u8) -&gt; []const u8`</span></span>
<span class="line" id="L91">        <span class="tok-comment">/// different implementations can</span></span>
<span class="line" id="L92">        <span class="tok-comment">///   - either decode, lookup and compare passwords</span></span>
<span class="line" id="L93">        <span class="tok-comment">///   - or just check for existence of the base64-encoded user:pass combination</span></span>
<span class="line" id="L94">        <span class="tok-comment">/// if realm is provided (not null), a copy of it is taken -&gt; call deinit() to clean up</span></span>
<span class="line" id="L95">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: std.mem.Allocator, lookup: *Lookup, realm: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !Self {</span>
<span class="line" id="L96">            <span class="tok-kw">return</span> .{</span>
<span class="line" id="L97">                .allocator = allocator,</span>
<span class="line" id="L98">                .lookup = lookup,</span>
<span class="line" id="L99">                .realm = <span class="tok-kw">if</span> (realm) |the_realm| <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, the_realm) <span class="tok-kw">else</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L100">            };</span>
<span class="line" id="L101">        }</span>
<span class="line" id="L102"></span>
<span class="line" id="L103">        <span class="tok-comment">/// Deinit the authenticator.</span></span>
<span class="line" id="L104">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L105">            <span class="tok-kw">if</span> (self.realm) |the_realm| {</span>
<span class="line" id="L106">                self.allocator.free(the_realm);</span>
<span class="line" id="L107">            }</span>
<span class="line" id="L108">        }</span>
<span class="line" id="L109"></span>
<span class="line" id="L110">        <span class="tok-comment">/// Use this to decode the auth_header into user:pass, lookup pass in lookup.</span></span>
<span class="line" id="L111">        <span class="tok-comment">/// Note: usually, you don't want to use this; you'd go for `authenticateRequest()`.</span></span>
<span class="line" id="L112">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">authenticateUserPass</span>(self: *Self, auth_header: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) AuthResult {</span>
<span class="line" id="L113">            zap.debug(<span class="tok-str">&quot;AuthenticateUserPass\n&quot;</span>, .{});</span>
<span class="line" id="L114">            <span class="tok-kw">const</span> encoded = auth_header[AuthScheme.Basic.str().len..];</span>
<span class="line" id="L115">            <span class="tok-kw">const</span> decoder = std.base64.standard.Decoder;</span>
<span class="line" id="L116">            <span class="tok-kw">var</span> buffer: [<span class="tok-number">0x100</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L117">            <span class="tok-kw">if</span> (decoder.calcSizeForSlice(encoded)) |decoded_size| {</span>
<span class="line" id="L118">                <span class="tok-kw">if</span> (decoded_size &gt;= buffer.len) {</span>
<span class="line" id="L119">                    zap.debug(</span>
<span class="line" id="L120">                        <span class="tok-str">&quot;ERROR: UserPassAuth: decoded_size {d} &gt;= buffer.len {d}\n&quot;</span>,</span>
<span class="line" id="L121">                        .{ decoded_size, buffer.len },</span>
<span class="line" id="L122">                    );</span>
<span class="line" id="L123">                    <span class="tok-kw">return</span> .AuthFailed;</span>
<span class="line" id="L124">                }</span>
<span class="line" id="L125">                <span class="tok-kw">const</span> decoded = buffer[<span class="tok-number">0</span>..decoded_size];</span>
<span class="line" id="L126">                decoder.decode(decoded, encoded) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L127">                    zap.debug(</span>
<span class="line" id="L128">                        <span class="tok-str">&quot;ERROR: UserPassAuth: unable to decode `{s}`: {any}\n&quot;</span>,</span>
<span class="line" id="L129">                        .{ encoded, err },</span>
<span class="line" id="L130">                    );</span>
<span class="line" id="L131">                    <span class="tok-kw">return</span> .AuthFailed;</span>
<span class="line" id="L132">                };</span>
<span class="line" id="L133">                <span class="tok-comment">// we have decoded</span>
</span>
<span class="line" id="L134">                <span class="tok-comment">// we can split</span>
</span>
<span class="line" id="L135">                <span class="tok-kw">var</span> it = std.mem.split(<span class="tok-type">u8</span>, decoded, <span class="tok-str">&quot;:&quot;</span>);</span>
<span class="line" id="L136">                <span class="tok-kw">const</span> user = it.next();</span>
<span class="line" id="L137">                <span class="tok-kw">const</span> pass = it.next();</span>
<span class="line" id="L138">                <span class="tok-kw">if</span> (user == <span class="tok-null">null</span> <span class="tok-kw">or</span> pass == <span class="tok-null">null</span>) {</span>
<span class="line" id="L139">                    zap.debug(</span>
<span class="line" id="L140">                        <span class="tok-str">&quot;ERROR: UserPassAuth: user {any} or pass {any} is null\n&quot;</span>,</span>
<span class="line" id="L141">                        .{ user, pass },</span>
<span class="line" id="L142">                    );</span>
<span class="line" id="L143">                    <span class="tok-kw">return</span> .AuthFailed;</span>
<span class="line" id="L144">                }</span>
<span class="line" id="L145">                <span class="tok-comment">// now, do the lookup</span>
</span>
<span class="line" id="L146">                <span class="tok-kw">const</span> actual_pw = self.lookup.*.get(user.?);</span>
<span class="line" id="L147">                <span class="tok-kw">if</span> (actual_pw) |pw| {</span>
<span class="line" id="L148">                    <span class="tok-kw">const</span> ret = std.mem.eql(<span class="tok-type">u8</span>, pass.?, pw);</span>
<span class="line" id="L149">                    zap.debug(</span>
<span class="line" id="L150">                        <span class="tok-str">&quot;INFO: UserPassAuth for user `{s}`: `{s}` == pass `{s}` = {}\n&quot;</span>,</span>
<span class="line" id="L151">                        .{ user.?, pw, pass.?, ret },</span>
<span class="line" id="L152">                    );</span>
<span class="line" id="L153">                    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (ret) .AuthOK <span class="tok-kw">else</span> .AuthFailed;</span>
<span class="line" id="L154">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L155">                    zap.debug(</span>
<span class="line" id="L156">                        <span class="tok-str">&quot;ERROR: UserPassAuth: user `{s}` not found in map of size {d}!\n&quot;</span>,</span>
<span class="line" id="L157">                        .{ user.?, self.lookup.*.count() },</span>
<span class="line" id="L158">                    );</span>
<span class="line" id="L159">                    <span class="tok-kw">return</span> .AuthFailed;</span>
<span class="line" id="L160">                }</span>
<span class="line" id="L161">            } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L162">                <span class="tok-comment">// can't calc slice size --&gt; fallthrough to return false</span>
</span>
<span class="line" id="L163">                zap.debug(</span>
<span class="line" id="L164">                    <span class="tok-str">&quot;ERROR: UserPassAuth: cannot calc slize size for encoded `{s}`: {any} \n&quot;</span>,</span>
<span class="line" id="L165">                    .{ encoded, err },</span>
<span class="line" id="L166">                );</span>
<span class="line" id="L167">                <span class="tok-kw">return</span> .AuthFailed;</span>
<span class="line" id="L168">            }</span>
<span class="line" id="L169">            zap.debug(<span class="tok-str">&quot;UNREACHABLE\n&quot;</span>, .{});</span>
<span class="line" id="L170">            <span class="tok-kw">return</span> .AuthFailed;</span>
<span class="line" id="L171">        }</span>
<span class="line" id="L172"></span>
<span class="line" id="L173">        <span class="tok-comment">/// Use this to just look up if the base64-encoded auth_header exists in lookup.</span></span>
<span class="line" id="L174">        <span class="tok-comment">/// Note: usually, you don't want to use this; you'd go for `authenticateRequest()`.</span></span>
<span class="line" id="L175">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">authenticateToken68</span>(self: *Self, auth_header: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) AuthResult {</span>
<span class="line" id="L176">            <span class="tok-kw">const</span> token = auth_header[AuthScheme.Basic.str().len..];</span>
<span class="line" id="L177">            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.lookup.*.contains(token)) .AuthOK <span class="tok-kw">else</span> .AuthFailed;</span>
<span class="line" id="L178">        }</span>
<span class="line" id="L179"></span>
<span class="line" id="L180">        <span class="tok-comment">/// dispatch based on kind (.UserPass / .Token689) and try to authenticate based on the header.</span></span>
<span class="line" id="L181">        <span class="tok-comment">/// Note: usually, you don't want to use this; you'd go for `authenticateRequest()`.</span></span>
<span class="line" id="L182">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">authenticate</span>(self: *Self, auth_header: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) AuthResult {</span>
<span class="line" id="L183">            zap.debug(<span class="tok-str">&quot;AUTHENTICATE\n&quot;</span>, .{});</span>
<span class="line" id="L184">            <span class="tok-kw">switch</span> (kind) {</span>
<span class="line" id="L185">                .UserPass =&gt; <span class="tok-kw">return</span> self.authenticateUserPass(auth_header),</span>
<span class="line" id="L186">                .Token68 =&gt; <span class="tok-kw">return</span> self.authenticateToken68(auth_header),</span>
<span class="line" id="L187">            }</span>
<span class="line" id="L188">        }</span>
<span class="line" id="L189"></span>
<span class="line" id="L190">        <span class="tok-comment">/// The zap authentication request handler.</span></span>
<span class="line" id="L191">        <span class="tok-comment">///</span></span>
<span class="line" id="L192">        <span class="tok-comment">/// Tries to extract the authentication header and perform the authentication.</span></span>
<span class="line" id="L193">        <span class="tok-comment">/// If no authentication header is found, an authorization header is tried.</span></span>
<span class="line" id="L194">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">authenticateRequest</span>(self: *Self, r: *<span class="tok-kw">const</span> zap.Request) AuthResult {</span>
<span class="line" id="L195">            zap.debug(<span class="tok-str">&quot;AUTHENTICATE REQUEST\n&quot;</span>, .{});</span>
<span class="line" id="L196">            <span class="tok-kw">if</span> (extractAuthHeader(.Basic, r)) |auth_header| {</span>
<span class="line" id="L197">                zap.debug(<span class="tok-str">&quot;Authentication Header found!\n&quot;</span>, .{});</span>
<span class="line" id="L198">                <span class="tok-kw">return</span> self.authenticate(auth_header);</span>
<span class="line" id="L199">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L200">                <span class="tok-comment">// try with .Authorization</span>
</span>
<span class="line" id="L201">                <span class="tok-kw">if</span> (extractAuthHeader(.Bearer, r)) |auth_header| {</span>
<span class="line" id="L202">                    zap.debug(<span class="tok-str">&quot;Authorization Header found!\n&quot;</span>, .{});</span>
<span class="line" id="L203">                    <span class="tok-kw">return</span> self.authenticate(auth_header);</span>
<span class="line" id="L204">                }</span>
<span class="line" id="L205">            }</span>
<span class="line" id="L206">            zap.debug(<span class="tok-str">&quot;NO fitting Auth Header found!\n&quot;</span>, .{});</span>
<span class="line" id="L207">            <span class="tok-kw">return</span> .AuthFailed;</span>
<span class="line" id="L208">        }</span>
<span class="line" id="L209">    };</span>
<span class="line" id="L210">}</span>
<span class="line" id="L211"></span>
<span class="line" id="L212"><span class="tok-comment">/// HTTP bearer authentication for a single token</span></span>
<span class="line" id="L213"><span class="tok-comment">/// RFC 6750</span></span>
<span class="line" id="L214"><span class="tok-comment">/// &quot;Authentication: Bearer TOKEN&quot;</span></span>
<span class="line" id="L215"><span class="tok-comment">/// `Bearer` is case-sensitive</span></span>
<span class="line" id="L216"><span class="tok-comment">///   - we don't support form-encoded `access_token` body parameter</span></span>
<span class="line" id="L217"><span class="tok-comment">///   - we don't support URI query parameter `access_token`</span></span>
<span class="line" id="L218"><span class="tok-comment">///</span></span>
<span class="line" id="L219"><span class="tok-comment">/// Errors:</span></span>
<span class="line" id="L220"><span class="tok-comment">/// HTTP/1.1 401 Unauthorized</span></span>
<span class="line" id="L221"><span class="tok-comment">/// WWW-Authenticate: Bearer realm=&quot;example&quot;, error=&quot;invalid_token&quot;, error_description=&quot;...&quot;</span></span>
<span class="line" id="L222"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> BearerSingle = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L223">    allocator: std.mem.Allocator,</span>
<span class="line" id="L224">    token: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L225">    realm: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L226"></span>
<span class="line" id="L227">    <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L228"></span>
<span class="line" id="L229">    <span class="tok-comment">/// Creates a Single-Token Bearer Authenticator.</span></span>
<span class="line" id="L230">    <span class="tok-comment">/// Takes a copy of the token.</span></span>
<span class="line" id="L231">    <span class="tok-comment">/// If realm is provided (not null), a copy is taken call deinit() to clean up.</span></span>
<span class="line" id="L232">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: std.mem.Allocator, token: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, realm: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !Self {</span>
<span class="line" id="L233">        <span class="tok-kw">return</span> .{</span>
<span class="line" id="L234">            .allocator = allocator,</span>
<span class="line" id="L235">            .token = <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, token),</span>
<span class="line" id="L236">            .realm = <span class="tok-kw">if</span> (realm) |the_realm| <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, the_realm) <span class="tok-kw">else</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L237">        };</span>
<span class="line" id="L238">    }</span>
<span class="line" id="L239"></span>
<span class="line" id="L240">    <span class="tok-comment">/// Try to authenticate based on the header.</span></span>
<span class="line" id="L241">    <span class="tok-comment">/// Note: usually, you don't want to use this; you'd go for `authenticateRequest()`.</span></span>
<span class="line" id="L242">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">authenticate</span>(self: *Self, auth_header: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) AuthResult {</span>
<span class="line" id="L243">        <span class="tok-kw">if</span> (checkAuthHeader(.Bearer, auth_header) == <span class="tok-null">false</span>) {</span>
<span class="line" id="L244">            <span class="tok-kw">return</span> .AuthFailed;</span>
<span class="line" id="L245">        }</span>
<span class="line" id="L246">        <span class="tok-kw">const</span> token = auth_header[AuthScheme.Bearer.str().len..];</span>
<span class="line" id="L247">        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (std.mem.eql(<span class="tok-type">u8</span>, token, self.token)) .AuthOK <span class="tok-kw">else</span> .AuthFailed;</span>
<span class="line" id="L248">    }</span>
<span class="line" id="L249"></span>
<span class="line" id="L250">    <span class="tok-comment">/// The zap authentication request handler.</span></span>
<span class="line" id="L251">    <span class="tok-comment">///</span></span>
<span class="line" id="L252">    <span class="tok-comment">/// Tries to extract the authentication header and perform the authentication.</span></span>
<span class="line" id="L253">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">authenticateRequest</span>(self: *Self, r: *<span class="tok-kw">const</span> zap.Request) AuthResult {</span>
<span class="line" id="L254">        <span class="tok-kw">if</span> (extractAuthHeader(.Bearer, r)) |auth_header| {</span>
<span class="line" id="L255">            <span class="tok-kw">return</span> self.authenticate(auth_header);</span>
<span class="line" id="L256">        }</span>
<span class="line" id="L257">        <span class="tok-kw">return</span> .AuthFailed;</span>
<span class="line" id="L258">    }</span>
<span class="line" id="L259"></span>
<span class="line" id="L260">    <span class="tok-comment">/// Deinits the authenticator.</span></span>
<span class="line" id="L261">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L262">        <span class="tok-kw">if</span> (self.realm) |the_realm| {</span>
<span class="line" id="L263">            self.allocator.free(the_realm);</span>
<span class="line" id="L264">        }</span>
<span class="line" id="L265">        self.allocator.free(self.token);</span>
<span class="line" id="L266">    }</span>
<span class="line" id="L267">};</span>
<span class="line" id="L268"></span>
<span class="line" id="L269"><span class="tok-comment">/// HTTP bearer authentication for multiple tokens</span></span>
<span class="line" id="L270"><span class="tok-comment">/// RFC 6750</span></span>
<span class="line" id="L271"><span class="tok-comment">/// &quot;Authentication: Bearer TOKEN&quot;</span></span>
<span class="line" id="L272"><span class="tok-comment">/// `Bearer` is case-sensitive</span></span>
<span class="line" id="L273"><span class="tok-comment">///   - we don't support form-encoded `access_token` body parameter</span></span>
<span class="line" id="L274"><span class="tok-comment">///   - we don't support URI query parameter `access_token`</span></span>
<span class="line" id="L275"><span class="tok-comment">///</span></span>
<span class="line" id="L276"><span class="tok-comment">/// Errors:</span></span>
<span class="line" id="L277"><span class="tok-comment">/// HTTP/1.1 401 Unauthorized</span></span>
<span class="line" id="L278"><span class="tok-comment">/// WWW-Authenticate: Bearer realm=&quot;example&quot;, error=&quot;invalid_token&quot;, error_description=&quot;...&quot;</span></span>
<span class="line" id="L279"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">BearerMulti</span>(<span class="tok-kw">comptime</span> Lookup: <span class="tok-type">type</span>) <span class="tok-type">type</span> {</span>
<span class="line" id="L280">    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L281">        allocator: std.mem.Allocator,</span>
<span class="line" id="L282">        lookup: *Lookup,</span>
<span class="line" id="L283">        realm: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L284"></span>
<span class="line" id="L285">        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L286"></span>
<span class="line" id="L287">        <span class="tok-comment">/// Creates a Multi Token Bearer Authenticator. `lookup` must implement</span></span>
<span class="line" id="L288">        <span class="tok-comment">/// `.get([]const u8) -&gt; []const u8` to look up tokens.</span></span>
<span class="line" id="L289">        <span class="tok-comment">/// If realm is provided (not null), a copy of it is taken -&gt; call deinit() to clean up.</span></span>
<span class="line" id="L290">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: std.mem.Allocator, lookup: *Lookup, realm: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !Self {</span>
<span class="line" id="L291">            <span class="tok-kw">return</span> .{</span>
<span class="line" id="L292">                .allocator = allocator,</span>
<span class="line" id="L293">                .lookup = lookup,</span>
<span class="line" id="L294">                .realm = <span class="tok-kw">if</span> (realm) |the_realm| <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, the_realm) <span class="tok-kw">else</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L295">            };</span>
<span class="line" id="L296">        }</span>
<span class="line" id="L297"></span>
<span class="line" id="L298">        <span class="tok-comment">/// Deinit the authenticator. Only required if a realm was provided at</span></span>
<span class="line" id="L299">        <span class="tok-comment">/// init() time.</span></span>
<span class="line" id="L300">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L301">            <span class="tok-kw">if</span> (self.realm) |the_realm| {</span>
<span class="line" id="L302">                self.allocator.free(the_realm);</span>
<span class="line" id="L303">            }</span>
<span class="line" id="L304">        }</span>
<span class="line" id="L305"></span>
<span class="line" id="L306">        <span class="tok-comment">/// Try to authenticate based on the header.</span></span>
<span class="line" id="L307">        <span class="tok-comment">/// Note: usually, you don't want to use this; you'd go for `authenticateRequest()`.</span></span>
<span class="line" id="L308">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">authenticate</span>(self: *Self, auth_header: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) AuthResult {</span>
<span class="line" id="L309">            <span class="tok-kw">if</span> (checkAuthHeader(.Bearer, auth_header) == <span class="tok-null">false</span>) {</span>
<span class="line" id="L310">                <span class="tok-kw">return</span> .AuthFailed;</span>
<span class="line" id="L311">            }</span>
<span class="line" id="L312">            <span class="tok-kw">const</span> token = auth_header[AuthScheme.Bearer.str().len..];</span>
<span class="line" id="L313">            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self.lookup.*.contains(token)) .AuthOK <span class="tok-kw">else</span> .AuthFailed;</span>
<span class="line" id="L314">        }</span>
<span class="line" id="L315"></span>
<span class="line" id="L316">        <span class="tok-comment">/// The zap authentication request handler.</span></span>
<span class="line" id="L317">        <span class="tok-comment">///</span></span>
<span class="line" id="L318">        <span class="tok-comment">/// Tries to extract the authentication header and perform the authentication.</span></span>
<span class="line" id="L319">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">authenticateRequest</span>(self: *Self, r: *<span class="tok-kw">const</span> zap.Request) AuthResult {</span>
<span class="line" id="L320">            <span class="tok-kw">if</span> (extractAuthHeader(.Bearer, r)) |auth_header| {</span>
<span class="line" id="L321">                <span class="tok-kw">return</span> self.authenticate(auth_header);</span>
<span class="line" id="L322">            }</span>
<span class="line" id="L323">            <span class="tok-kw">return</span> .AuthFailed;</span>
<span class="line" id="L324">        }</span>
<span class="line" id="L325">    };</span>
<span class="line" id="L326">}</span>
<span class="line" id="L327"></span>
<span class="line" id="L328"><span class="tok-comment">/// Settings to initialize a UserPassSession authenticator.</span></span>
<span class="line" id="L329"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> UserPassSessionArgs = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L330">    <span class="tok-comment">/// username body parameter</span></span>
<span class="line" id="L331">    usernameParam: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L332">    <span class="tok-comment">/// password body parameter</span></span>
<span class="line" id="L333">    passwordParam: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L334">    <span class="tok-comment">/// redirect to this page if auth fails</span></span>
<span class="line" id="L335">    loginPage: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L336">    <span class="tok-comment">/// name of the auth cookie</span></span>
<span class="line" id="L337">    cookieName: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L338">    <span class="tok-comment">/// cookie max age in seconds; 0 -&gt; session cookie</span></span>
<span class="line" id="L339">    cookieMaxAge: <span class="tok-type">u8</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L340">    <span class="tok-comment">/// redirect status code, defaults to 302 found</span></span>
<span class="line" id="L341">    redirectCode: zap.StatusCode = .found,</span>
<span class="line" id="L342">};</span>
<span class="line" id="L343"></span>
<span class="line" id="L344"><span class="tok-comment">/// UserPassSession supports the following use case:</span></span>
<span class="line" id="L345"><span class="tok-comment">///</span></span>
<span class="line" id="L346"><span class="tok-comment">/// - checks every request: is it going to the login page? -&gt; let the request through.</span></span>
<span class="line" id="L347"><span class="tok-comment">/// - else:</span></span>
<span class="line" id="L348"><span class="tok-comment">///   - checks every request for a session token in a cookie</span></span>
<span class="line" id="L349"><span class="tok-comment">///   - if there is no token, it checks for correct username and password body params</span></span>
<span class="line" id="L350"><span class="tok-comment">///     - if username and password are present and correct, it will create a session token,</span></span>
<span class="line" id="L351"><span class="tok-comment">///       create a response cookie containing the token, and carry on with the request</span></span>
<span class="line" id="L352"><span class="tok-comment">///     - else it will redirect to the login page</span></span>
<span class="line" id="L353"><span class="tok-comment">///   - if the session token is present and correct: it will let the request through</span></span>
<span class="line" id="L354"><span class="tok-comment">///   - else: it will redirect to the login page</span></span>
<span class="line" id="L355"><span class="tok-comment">///</span></span>
<span class="line" id="L356"><span class="tok-comment">/// Please note the implications of this simple approach: IF YOU REUSE &quot;username&quot;</span></span>
<span class="line" id="L357"><span class="tok-comment">/// and &quot;password&quot; body params for anything else in your application, then the</span></span>
<span class="line" id="L358"><span class="tok-comment">/// mechanisms described above will still kick in. For that reason: please know what</span></span>
<span class="line" id="L359"><span class="tok-comment">/// you're doing.</span></span>
<span class="line" id="L360"><span class="tok-comment">///</span></span>
<span class="line" id="L361"><span class="tok-comment">/// See UserPassSessionArgs:</span></span>
<span class="line" id="L362"><span class="tok-comment">/// - username &amp; password param names can be defined by you</span></span>
<span class="line" id="L363"><span class="tok-comment">/// - session cookie name and max-age can be defined by you</span></span>
<span class="line" id="L364"><span class="tok-comment">/// - login page and redirect code (.302) can be defined by you</span></span>
<span class="line" id="L365"><span class="tok-comment">///</span></span>
<span class="line" id="L366"><span class="tok-comment">/// Comptime Parameters:</span></span>
<span class="line" id="L367"><span class="tok-comment">///</span></span>
<span class="line" id="L368"><span class="tok-comment">/// - `Lookup` must implement .get([]const u8) -&gt; []const u8 for user password retrieval</span></span>
<span class="line" id="L369"><span class="tok-comment">/// - `lockedPwLookups` : if true, accessing the provided Lookup instance will be protected</span></span>
<span class="line" id="L370"><span class="tok-comment">///    by a Mutex. You can access the mutex yourself via the `passwordLookupLock`.</span></span>
<span class="line" id="L371"><span class="tok-comment">///</span></span>
<span class="line" id="L372"><span class="tok-comment">/// Note: In order to be quick, you can set lockedTokenLookups to false.</span></span>
<span class="line" id="L373"><span class="tok-comment">///       -&gt; we generate it on init() and leave it static</span></span>
<span class="line" id="L374"><span class="tok-comment">///       -&gt; there is no way to 100% log out apart from re-starting the server</span></span>
<span class="line" id="L375"><span class="tok-comment">///       -&gt; because: we send a cookie to the browser that invalidates the session cookie</span></span>
<span class="line" id="L376"><span class="tok-comment">///       -&gt; another browser program with the page still open would still be able to use</span></span>
<span class="line" id="L377"><span class="tok-comment">///       -&gt; the session. Which is kindof OK, but not as cool as erasing the token</span></span>
<span class="line" id="L378"><span class="tok-comment">///       -&gt; on the server side which immediately block all other browsers as well.</span></span>
<span class="line" id="L379"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">UserPassSession</span>(<span class="tok-kw">comptime</span> Lookup: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> lockedPwLookups: <span class="tok-type">bool</span>) <span class="tok-type">type</span> {</span>
<span class="line" id="L380">    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L381">        allocator: std.mem.Allocator,</span>
<span class="line" id="L382">        lookup: *Lookup,</span>
<span class="line" id="L383">        settings: UserPassSessionArgs,</span>
<span class="line" id="L384"></span>
<span class="line" id="L385">        <span class="tok-comment">// TODO: cookie store per user?</span>
</span>
<span class="line" id="L386">        sessionTokens: SessionTokenMap,</span>
<span class="line" id="L387">        passwordLookupLock: std.Thread.Mutex = .{},</span>
<span class="line" id="L388">        tokenLookupLock: std.Thread.Mutex = .{},</span>
<span class="line" id="L389"></span>
<span class="line" id="L390">        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L391">        <span class="tok-kw">const</span> SessionTokenMap = std.StringHashMap(<span class="tok-type">void</span>);</span>
<span class="line" id="L392">        <span class="tok-kw">const</span> Hash = std.crypto.hash.sha2.Sha256;</span>
<span class="line" id="L393"></span>
<span class="line" id="L394">        <span class="tok-kw">const</span> Token = [Hash.digest_length * <span class="tok-number">2</span>]<span class="tok-type">u8</span>;</span>
<span class="line" id="L395"></span>
<span class="line" id="L396">        <span class="tok-comment">/// Construct this authenticator. See above and related types for more</span></span>
<span class="line" id="L397">        <span class="tok-comment">/// information.</span></span>
<span class="line" id="L398">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(</span>
<span class="line" id="L399">            allocator: std.mem.Allocator,</span>
<span class="line" id="L400">            lookup: *Lookup,</span>
<span class="line" id="L401">            args: UserPassSessionArgs,</span>
<span class="line" id="L402">        ) !Self {</span>
<span class="line" id="L403">            <span class="tok-kw">const</span> ret: Self = .{</span>
<span class="line" id="L404">                .allocator = allocator,</span>
<span class="line" id="L405">                .settings = .{</span>
<span class="line" id="L406">                    .usernameParam = <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, args.usernameParam),</span>
<span class="line" id="L407">                    .passwordParam = <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, args.passwordParam),</span>
<span class="line" id="L408">                    .loginPage = <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, args.loginPage),</span>
<span class="line" id="L409">                    .cookieName = <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, args.cookieName),</span>
<span class="line" id="L410">                    .cookieMaxAge = args.cookieMaxAge,</span>
<span class="line" id="L411">                    .redirectCode = args.redirectCode,</span>
<span class="line" id="L412">                },</span>
<span class="line" id="L413">                .lookup = lookup,</span>
<span class="line" id="L414">                .sessionTokens = SessionTokenMap.init(allocator),</span>
<span class="line" id="L415">            };</span>
<span class="line" id="L416"></span>
<span class="line" id="L417">            <span class="tok-kw">return</span> ret;</span>
<span class="line" id="L418">        }</span>
<span class="line" id="L419"></span>
<span class="line" id="L420">        <span class="tok-comment">/// De-init this authenticator.</span></span>
<span class="line" id="L421">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L422">            self.allocator.free(self.settings.usernameParam);</span>
<span class="line" id="L423">            self.allocator.free(self.settings.passwordParam);</span>
<span class="line" id="L424">            self.allocator.free(self.settings.loginPage);</span>
<span class="line" id="L425">            self.allocator.free(self.settings.cookieName);</span>
<span class="line" id="L426"></span>
<span class="line" id="L427">            <span class="tok-comment">// clean up the session tokens: the key strings are duped</span>
</span>
<span class="line" id="L428">            <span class="tok-kw">var</span> key_it = self.sessionTokens.keyIterator();</span>
<span class="line" id="L429">            <span class="tok-kw">while</span> (key_it.next()) |key_ptr| {</span>
<span class="line" id="L430">                self.allocator.free(key_ptr.*);</span>
<span class="line" id="L431">            }</span>
<span class="line" id="L432">            self.sessionTokens.deinit();</span>
<span class="line" id="L433">        }</span>
<span class="line" id="L434"></span>
<span class="line" id="L435">        <span class="tok-comment">/// Check for session token cookie, remove the token from the valid tokens</span></span>
<span class="line" id="L436">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">logout</span>(self: *Self, r: *<span class="tok-kw">const</span> zap.Request) <span class="tok-type">void</span> {</span>
<span class="line" id="L437">            <span class="tok-comment">// we  erase the list of valid tokens server-side (later) and set the</span>
</span>
<span class="line" id="L438">            <span class="tok-comment">// cookie to &quot;invalid&quot; on the client side.</span>
</span>
<span class="line" id="L439">            <span class="tok-kw">if</span> (r.setCookie(.{</span>
<span class="line" id="L440">                .name = self.settings.cookieName,</span>
<span class="line" id="L441">                .value = <span class="tok-str">&quot;invalid&quot;</span>,</span>
<span class="line" id="L442">                .max_age_s = -<span class="tok-number">1</span>,</span>
<span class="line" id="L443">            })) {</span>
<span class="line" id="L444">                zap.debug(<span class="tok-str">&quot;logout ok\n&quot;</span>, .{});</span>
<span class="line" id="L445">            } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L446">                zap.debug(<span class="tok-str">&quot;logout cookie setting failed: {any}\n&quot;</span>, .{err});</span>
<span class="line" id="L447">            }</span>
<span class="line" id="L448"></span>
<span class="line" id="L449">            r.parseCookies(<span class="tok-null">false</span>);</span>
<span class="line" id="L450"></span>
<span class="line" id="L451">            <span class="tok-comment">// check for session cookie</span>
</span>
<span class="line" id="L452">            <span class="tok-kw">if</span> (r.getCookieStr(self.allocator, self.settings.cookieName, <span class="tok-null">false</span>)) |maybe_cookie| {</span>
<span class="line" id="L453">                <span class="tok-kw">if</span> (maybe_cookie) |cookie| {</span>
<span class="line" id="L454">                    <span class="tok-kw">defer</span> cookie.deinit();</span>
<span class="line" id="L455">                    self.tokenLookupLock.lock();</span>
<span class="line" id="L456">                    <span class="tok-kw">defer</span> self.tokenLookupLock.unlock();</span>
<span class="line" id="L457">                    <span class="tok-kw">if</span> (self.sessionTokens.getKeyPtr(cookie.str)) |keyPtr| {</span>
<span class="line" id="L458">                        <span class="tok-kw">const</span> keySlice = keyPtr.*;</span>
<span class="line" id="L459">                        <span class="tok-comment">// if cookie is a valid session, remove it!</span>
</span>
<span class="line" id="L460">                        _ = self.sessionTokens.remove(cookie.str);</span>
<span class="line" id="L461">                        <span class="tok-comment">// only now can we let go of the cookie str slice that</span>
</span>
<span class="line" id="L462">                        <span class="tok-comment">// was used as the key</span>
</span>
<span class="line" id="L463">                        self.allocator.free(keySlice);</span>
<span class="line" id="L464">                    }</span>
<span class="line" id="L465">                }</span>
<span class="line" id="L466">            } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L467">                zap.debug(<span class="tok-str">&quot;unreachable: UserPassSession.logout: {any}&quot;</span>, .{err});</span>
<span class="line" id="L468">            }</span>
<span class="line" id="L469">        }</span>
<span class="line" id="L470"></span>
<span class="line" id="L471">        <span class="tok-kw">fn</span> <span class="tok-fn">_internal_authenticateRequest</span>(self: *Self, r: *<span class="tok-kw">const</span> zap.Request) AuthResult {</span>
<span class="line" id="L472">            <span class="tok-comment">// if we're requesting the login page, let the request through</span>
</span>
<span class="line" id="L473">            <span class="tok-kw">if</span> (r.path) |p| {</span>
<span class="line" id="L474">                <span class="tok-kw">if</span> (std.mem.startsWith(<span class="tok-type">u8</span>, p, self.settings.loginPage)) {</span>
<span class="line" id="L475">                    <span class="tok-kw">return</span> .AuthOK;</span>
<span class="line" id="L476">                }</span>
<span class="line" id="L477">            }</span>
<span class="line" id="L478"></span>
<span class="line" id="L479">            <span class="tok-comment">// parse body</span>
</span>
<span class="line" id="L480">            r.parseBody() <span class="tok-kw">catch</span> {</span>
<span class="line" id="L481">                <span class="tok-comment">// zap.debug(&quot;warning: parseBody() failed in UserPassSession: {any}&quot;, .{err});</span>
</span>
<span class="line" id="L482">                <span class="tok-comment">// this is not an error in case of e.g. gets with querystrings</span>
</span>
<span class="line" id="L483">            };</span>
<span class="line" id="L484"></span>
<span class="line" id="L485">            r.parseCookies(<span class="tok-null">false</span>);</span>
<span class="line" id="L486"></span>
<span class="line" id="L487">            <span class="tok-comment">// check for session cookie</span>
</span>
<span class="line" id="L488">            <span class="tok-kw">if</span> (r.getCookieStr(self.allocator, self.settings.cookieName, <span class="tok-null">false</span>)) |maybe_cookie| {</span>
<span class="line" id="L489">                <span class="tok-kw">if</span> (maybe_cookie) |cookie| {</span>
<span class="line" id="L490">                    <span class="tok-kw">defer</span> cookie.deinit();</span>
<span class="line" id="L491">                    <span class="tok-comment">// locked or unlocked token lookup</span>
</span>
<span class="line" id="L492">                    self.tokenLookupLock.lock();</span>
<span class="line" id="L493">                    <span class="tok-kw">defer</span> self.tokenLookupLock.unlock();</span>
<span class="line" id="L494">                    <span class="tok-kw">if</span> (self.sessionTokens.contains(cookie.str)) {</span>
<span class="line" id="L495">                        <span class="tok-comment">// cookie is a valid session!</span>
</span>
<span class="line" id="L496">                        zap.debug(<span class="tok-str">&quot;Auth: COOKIE IS OK!!!!: {s}\n&quot;</span>, .{cookie.str});</span>
<span class="line" id="L497">                        <span class="tok-kw">return</span> .AuthOK;</span>
<span class="line" id="L498">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L499">                        zap.debug(<span class="tok-str">&quot;Auth: COOKIE IS BAD!!!!: {s}\n&quot;</span>, .{cookie.str});</span>
<span class="line" id="L500">                        <span class="tok-comment">// this is not necessarily a bad thing. it could be a</span>
</span>
<span class="line" id="L501">                        <span class="tok-comment">// stale cookie from a previous session. So let's check</span>
</span>
<span class="line" id="L502">                        <span class="tok-comment">// if username and password are being sent and correct.</span>
</span>
<span class="line" id="L503">                    }</span>
<span class="line" id="L504">                }</span>
<span class="line" id="L505">            } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L506">                zap.debug(<span class="tok-str">&quot;unreachable: could not check for cookie in UserPassSession: {any}&quot;</span>, .{err});</span>
<span class="line" id="L507">            }</span>
<span class="line" id="L508"></span>
<span class="line" id="L509">            <span class="tok-comment">// get params of username and password</span>
</span>
<span class="line" id="L510">            <span class="tok-kw">if</span> (r.getParamStr(self.allocator, self.settings.usernameParam, <span class="tok-null">false</span>)) |maybe_username| {</span>
<span class="line" id="L511">                <span class="tok-kw">if</span> (maybe_username) |*username| {</span>
<span class="line" id="L512">                    <span class="tok-kw">defer</span> username.deinit();</span>
<span class="line" id="L513">                    <span class="tok-kw">if</span> (r.getParamStr(self.allocator, self.settings.passwordParam, <span class="tok-null">false</span>)) |maybe_pw| {</span>
<span class="line" id="L514">                        <span class="tok-kw">if</span> (maybe_pw) |*pw| {</span>
<span class="line" id="L515">                            <span class="tok-kw">defer</span> pw.deinit();</span>
<span class="line" id="L516"></span>
<span class="line" id="L517">                            <span class="tok-comment">// now check</span>
</span>
<span class="line" id="L518">                            <span class="tok-kw">const</span> correct_pw_optional = brk: {</span>
<span class="line" id="L519">                                <span class="tok-kw">if</span> (lockedPwLookups) {</span>
<span class="line" id="L520">                                    self.passwordLookupLock.lock();</span>
<span class="line" id="L521">                                    <span class="tok-kw">defer</span> self.passwordLookupLock.unlock();</span>
<span class="line" id="L522">                                    <span class="tok-kw">break</span> :brk self.lookup.*.get(username.str);</span>
<span class="line" id="L523">                                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L524">                                    <span class="tok-kw">break</span> :brk self.lookup.*.get(username.str);</span>
<span class="line" id="L525">                                }</span>
<span class="line" id="L526">                            };</span>
<span class="line" id="L527">                            <span class="tok-kw">if</span> (correct_pw_optional) |correct_pw| {</span>
<span class="line" id="L528">                                <span class="tok-kw">if</span> (std.mem.eql(<span class="tok-type">u8</span>, pw.str, correct_pw)) {</span>
<span class="line" id="L529">                                    <span class="tok-comment">// create session token</span>
</span>
<span class="line" id="L530">                                    <span class="tok-kw">if</span> (self.createAndStoreSessionToken(username.str, pw.str)) |token| {</span>
<span class="line" id="L531">                                        <span class="tok-kw">defer</span> self.allocator.free(token);</span>
<span class="line" id="L532">                                        <span class="tok-comment">// now set the cookie header</span>
</span>
<span class="line" id="L533">                                        <span class="tok-kw">if</span> (r.setCookie(.{</span>
<span class="line" id="L534">                                            .name = self.settings.cookieName,</span>
<span class="line" id="L535">                                            .value = token,</span>
<span class="line" id="L536">                                            .max_age_s = self.settings.cookieMaxAge,</span>
<span class="line" id="L537">                                        })) {</span>
<span class="line" id="L538">                                            <span class="tok-kw">return</span> .AuthOK;</span>
<span class="line" id="L539">                                        } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L540">                                            zap.debug(<span class="tok-str">&quot;could not set session token: {any}&quot;</span>, .{err});</span>
<span class="line" id="L541">                                        }</span>
<span class="line" id="L542">                                    } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L543">                                        zap.debug(<span class="tok-str">&quot;could not create session token: {any}&quot;</span>, .{err});</span>
<span class="line" id="L544">                                    }</span>
<span class="line" id="L545">                                    <span class="tok-comment">// errors with token don't mean the auth itself wasn't OK</span>
</span>
<span class="line" id="L546">                                    <span class="tok-kw">return</span> .AuthOK;</span>
<span class="line" id="L547">                                }</span>
<span class="line" id="L548">                            }</span>
<span class="line" id="L549">                        }</span>
<span class="line" id="L550">                    } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L551">                        zap.debug(<span class="tok-str">&quot;getParamSt() for password failed in UserPassSession: {any}&quot;</span>, .{err});</span>
<span class="line" id="L552">                        <span class="tok-kw">return</span> .AuthFailed;</span>
<span class="line" id="L553">                    }</span>
<span class="line" id="L554">                }</span>
<span class="line" id="L555">            } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L556">                zap.debug(<span class="tok-str">&quot;getParamSt() for user failed in UserPassSession: {any}&quot;</span>, .{err});</span>
<span class="line" id="L557">                <span class="tok-kw">return</span> .AuthFailed;</span>
<span class="line" id="L558">            }</span>
<span class="line" id="L559">            <span class="tok-kw">return</span> .AuthFailed;</span>
<span class="line" id="L560">        }</span>
<span class="line" id="L561"></span>
<span class="line" id="L562">        <span class="tok-comment">/// The zap authentication request handler.</span></span>
<span class="line" id="L563">        <span class="tok-comment">///</span></span>
<span class="line" id="L564">        <span class="tok-comment">/// See above for how it works.</span></span>
<span class="line" id="L565">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">authenticateRequest</span>(self: *Self, r: *<span class="tok-kw">const</span> zap.Request) AuthResult {</span>
<span class="line" id="L566">            <span class="tok-kw">switch</span> (self._internal_authenticateRequest(r)) {</span>
<span class="line" id="L567">                .AuthOK =&gt; {</span>
<span class="line" id="L568">                    <span class="tok-comment">// username and pass are ok -&gt; created token, set header, caller can continue</span>
</span>
<span class="line" id="L569">                    <span class="tok-kw">return</span> .AuthOK;</span>
<span class="line" id="L570">                },</span>
<span class="line" id="L571">                <span class="tok-comment">// this does not happen, just for completeness</span>
</span>
<span class="line" id="L572">                .Handled =&gt; <span class="tok-kw">return</span> .Handled,</span>
<span class="line" id="L573">                <span class="tok-comment">// auth failed -&gt; redirect</span>
</span>
<span class="line" id="L574">                .AuthFailed =&gt; {</span>
<span class="line" id="L575">                    <span class="tok-comment">// we need to redirect and return .Handled</span>
</span>
<span class="line" id="L576">                    self.redirect(r) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L577">                        <span class="tok-comment">// we just give up</span>
</span>
<span class="line" id="L578">                        zap.debug(<span class="tok-str">&quot;redirect() failed in UserPassSession: {any}&quot;</span>, .{err});</span>
<span class="line" id="L579">                    };</span>
<span class="line" id="L580">                    <span class="tok-kw">return</span> .Handled;</span>
<span class="line" id="L581">                },</span>
<span class="line" id="L582">            }</span>
<span class="line" id="L583">        }</span>
<span class="line" id="L584"></span>
<span class="line" id="L585">        <span class="tok-kw">fn</span> <span class="tok-fn">redirect</span>(self: *Self, r: *<span class="tok-kw">const</span> zap.Request) !<span class="tok-type">void</span> {</span>
<span class="line" id="L586">            <span class="tok-kw">try</span> r.redirectTo(self.settings.loginPage, self.settings.redirectCode);</span>
<span class="line" id="L587">        }</span>
<span class="line" id="L588"></span>
<span class="line" id="L589">        <span class="tok-kw">fn</span> <span class="tok-fn">createSessionToken</span>(self: *Self, username: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, password: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L590">            <span class="tok-kw">var</span> hasher = Hash.init(.{});</span>
<span class="line" id="L591">            hasher.update(username);</span>
<span class="line" id="L592">            hasher.update(password);</span>
<span class="line" id="L593">            <span class="tok-kw">var</span> buf: [<span class="tok-number">16</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L594">            <span class="tok-kw">const</span> time_nano = std.time.nanoTimestamp();</span>
<span class="line" id="L595">            <span class="tok-kw">const</span> timestampHex = <span class="tok-kw">try</span> std.fmt.bufPrint(&amp;buf, <span class="tok-str">&quot;{0x}&quot;</span>, .{time_nano});</span>
<span class="line" id="L596">            hasher.update(timestampHex);</span>
<span class="line" id="L597"></span>
<span class="line" id="L598">            <span class="tok-kw">var</span> digest: [Hash.digest_length]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L599">            hasher.final(&amp;digest);</span>
<span class="line" id="L600">            <span class="tok-kw">const</span> token: Token = std.fmt.bytesToHex(digest, .lower);</span>
<span class="line" id="L601">            <span class="tok-kw">const</span> token_str = <span class="tok-kw">try</span> self.allocator.dupe(<span class="tok-type">u8</span>, token[<span class="tok-number">0</span>..token.len]);</span>
<span class="line" id="L602">            <span class="tok-kw">return</span> token_str;</span>
<span class="line" id="L603">        }</span>
<span class="line" id="L604"></span>
<span class="line" id="L605">        <span class="tok-kw">fn</span> <span class="tok-fn">createAndStoreSessionToken</span>(self: *Self, username: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, password: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L606">            <span class="tok-kw">const</span> token = <span class="tok-kw">try</span> self.createSessionToken(username, password);</span>
<span class="line" id="L607">            self.tokenLookupLock.lock();</span>
<span class="line" id="L608">            <span class="tok-kw">defer</span> self.tokenLookupLock.unlock();</span>
<span class="line" id="L609"></span>
<span class="line" id="L610">            <span class="tok-kw">if</span> (!self.sessionTokens.contains(token)) {</span>
<span class="line" id="L611">                <span class="tok-kw">try</span> self.sessionTokens.put(<span class="tok-kw">try</span> self.allocator.dupe(<span class="tok-type">u8</span>, token), {});</span>
<span class="line" id="L612">            }</span>
<span class="line" id="L613">            <span class="tok-kw">return</span> token;</span>
<span class="line" id="L614">        }</span>
<span class="line" id="L615">    };</span>
<span class="line" id="L616">}</span>
<span class="line" id="L617"></span>
</code></pre></body>
</html>